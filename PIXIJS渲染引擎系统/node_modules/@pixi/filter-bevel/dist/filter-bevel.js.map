{"version":3,"file":"filter-bevel.js","sources":["../src/BevelFilter.ts"],"sourcesContent":["import { vertex } from '@tools/fragments';\nimport fragment from './bevel.frag';\nimport { Filter, DEG_TO_RAD, utils } from '@pixi/core';\n\ninterface BevelFilterOptions\n{\n    rotation: number,\n    thickness: number,\n    lightColor: number,\n    lightAlpha: number,\n    shadowColor: number,\n    shadowAlpha: number,\n}\n\n/**\n * Bevel Filter.<br>\n * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/bevel.png)\n *\n * @class\n * @extends PIXI.Filter\n * @see {@link https://www.npmjs.com/package/@pixi/filter-bevel|@pixi/filter-bevel}\n * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}\n */\nclass BevelFilter extends Filter\n{\n    private _thickness = 2;\n    private _angle = 0;\n\n    /**\n     * @param {object} [options] - The optional parameters of the filter.\n     * @param {number} [options.rotation = 45] - The angle of the light in degrees.\n     * @param {number} [options.thickness = 2] - The tickness of the bevel.\n     * @param {number} [options.lightColor = 0xffffff] - Color of the light.\n     * @param {number} [options.lightAlpha = 0.7] - Alpha of the light.\n     * @param {number} [options.shadowColor = 0x000000] - Color of the shadow.\n     * @param {number} [options.shadowAlpha = 0.7] - Alpha of the shadow.\n     */\n    constructor(options?: Partial<BevelFilterOptions>)\n    {\n        super(vertex, fragment);\n\n        this.uniforms.lightColor = new Float32Array(3);\n        this.uniforms.shadowColor = new Float32Array(3);\n\n        Object.assign(this, {\n            rotation: 45,\n            thickness: 2,\n            lightColor: 0xffffff,\n            lightAlpha: 0.7,\n            shadowColor: 0x000000,\n            shadowAlpha: 0.7,\n        }, options);\n\n        // Workaround: https://github.com/pixijs/filters/issues/230\n        // applies correctly only if there is at least a single-pixel padding with alpha=0 around an image\n        // To solve this problem, a padding of 1 put on the filter should suffice\n        this.padding = 1;\n    }\n\n    /**\n     * Update the transform matrix of offset angle.\n     * @private\n     */\n    private _updateTransform()\n    {\n        this.uniforms.transformX = this._thickness * Math.cos(this._angle);\n        this.uniforms.transformY = this._thickness * Math.sin(this._angle);\n    }\n\n    /**\n     * The angle of the light in degrees.\n     * @default 45\n     */\n    get rotation(): number\n    {\n        return this._angle / DEG_TO_RAD;\n    }\n    set rotation(value: number)\n    {\n        this._angle = value * DEG_TO_RAD;\n        this._updateTransform();\n    }\n\n    /**\n     * The tickness of the bevel.\n     * @default 2\n     */\n    get thickness(): number\n    {\n        return this._thickness;\n    }\n    set thickness(value: number)\n    {\n        this._thickness = value;\n        this._updateTransform();\n    }\n\n    /**\n     * Color of the light.\n     * @default 0xffffff\n     */\n    get lightColor(): number\n    {\n        return utils.rgb2hex(this.uniforms.lightColor);\n    }\n    set lightColor(value: number)\n    {\n        utils.hex2rgb(value, this.uniforms.lightColor);\n    }\n\n    /**\n     * Alpha of the light.\n     * @default 0.7\n     */\n    get lightAlpha(): number\n    {\n        return this.uniforms.lightAlpha;\n    }\n    set lightAlpha(value: number)\n    {\n        this.uniforms.lightAlpha = value;\n    }\n\n    /**\n     * Color of the shadow.\n     * @default 0x000000\n     */\n    get shadowColor(): number\n    {\n        return utils.rgb2hex(this.uniforms.shadowColor);\n    }\n    set shadowColor(value: number)\n    {\n        utils.hex2rgb(value, this.uniforms.shadowColor);\n    }\n\n    /**\n     * Alpha of the shadow.\n     * @default 0.7\n     */\n    get shadowAlpha(): number\n    {\n        return this.uniforms.shadowAlpha;\n    }\n    set shadowAlpha(value: number)\n    {\n        this.uniforms.shadowAlpha = value;\n    }\n}\n\nexport { BevelFilter };\nexport type { BevelFilterOptions };\n"],"names":["BevelFilter","Filter","options","vertex","fragment","DEG_TO_RAD","value","utils"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAuBA,MAAMA,UAAoBC,EAC1B,MAAA,CAaI,YAAYC,EACZ,CACI,MAAMC,EAAQC,CAAQ,EAd1B,KAAQ,WAAa,EACrB,KAAQ,OAAS,EAeb,KAAK,SAAS,WAAa,IAAI,aAAa,CAAC,EAC7C,KAAK,SAAS,YAAc,IAAI,aAAa,CAAC,EAE9C,OAAO,OAAO,KAAM,CAChB,SAAU,GACV,UAAW,EACX,WAAY,SACZ,WAAY,GACZ,YAAa,EACb,YAAa,EACjB,EAAGF,CAAO,EAKV,KAAK,QAAU,CACnB,CAMQ,kBACR,CACI,KAAK,SAAS,WAAa,KAAK,WAAa,KAAK,IAAI,KAAK,MAAM,EACjE,KAAK,SAAS,WAAa,KAAK,WAAa,KAAK,IAAI,KAAK,MAAM,CACrE,CAMA,IAAI,UACJ,CACI,OAAO,KAAK,OAASG,EAAAA,UACzB,CACA,IAAI,SAASC,EACb,CACI,KAAK,OAASA,EAAQD,EAAAA,WACtB,KAAK,kBACT,CAMA,IAAI,WACJ,CACI,OAAO,KAAK,UAChB,CACA,IAAI,UAAUC,EACd,CACI,KAAK,WAAaA,EAClB,KAAK,iBACT,CAAA,CAMA,IAAI,YACJ,CACI,OAAOC,EAAM,MAAA,QAAQ,KAAK,SAAS,UAAU,CACjD,CACA,IAAI,WAAWD,EACf,CACIC,EAAAA,MAAM,QAAQD,EAAO,KAAK,SAAS,UAAU,CACjD,CAMA,IAAI,YACJ,CACI,OAAO,KAAK,SAAS,UACzB,CACA,IAAI,WAAWA,EACf,CACI,KAAK,SAAS,WAAaA,CAC/B,CAMA,IAAI,aACJ,CACI,OAAOC,EAAAA,MAAM,QAAQ,KAAK,SAAS,WAAW,CAClD,CACA,IAAI,YAAYD,EAChB,CACIC,EAAAA,MAAM,QAAQD,EAAO,KAAK,SAAS,WAAW,CAClD,CAMA,IAAI,aACJ,CACI,OAAO,KAAK,SAAS,WACzB,CACA,IAAI,YAAYA,EAChB,CACI,KAAK,SAAS,YAAcA,CAChC,CACJ"}